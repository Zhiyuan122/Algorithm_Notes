public class BitOperationAddMinusMultiplyDivide {

	public static int MIN = Integer.MIN_VALUE;
	//整数最小值：负的21亿多

	public static int divide(int a, int b) {
		if (a == MIN && b == MIN) {
			// a和b都是整数最小
			return 1;
		}
		if (a != MIN && b != MIN) {
			// a和b都不是整数最小，那么正常去除
			return div(a, b);
		}
		if (b == MIN) {
			// a不是整数最小，b是整数最小
			return 0;
		}
		// a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了
		if (b == neg(1)) {
			return Integer.MAX_VALUE;
		}
		// a是整数最小，b不是整数最小，b也不是-1
		a = add(a, b > 0 ? b : neg(b));
		int ans = div(a, b);
		int offset = b > 0 ? neg(1) : 1;
		return add(ans, offset);
	}

	// 必须保证a和b都不是整数最小值，返回a除以b的结果
	public static int div(int a, int b) {
		int x = a < 0 ? neg(a) : a;
		int y = b < 0 ? neg(b) : b;
		int ans = 0;
		for (int i = 30; i >= 0; i = minus(i, 1)) {//i--;
			if ((x >> i) >= y) {
				ans |= (1 << i);//结果里把相应i位置上的1或到ans里去
				x = minus(x, y << i);//然后x减去y*2^i这个值
			}
		}
		return a < 0 ^ b < 0 ? neg(ans) : ans;
	}

	public static int add(int a, int b) {
		int ans = a;
		//这里用B储存进位信息，是不是本质上也可以用一个新的变量表示进位信息
		//只是省了一个步骤
		while (b != 0) {
			// ans : a和b无进位相加的结果
			ans = a ^ b;
			// b : a和b相加时的进位信息
			b = (a & b) << 1;
			a = ans;
		}
		return ans;
	}

	public static int minus(int a, int b) {
		return add(a, neg(b));
	}

	public static int neg(int n) {
		return add(~n, 1);
	}


	public static int multiply(int a, int b) {
		int ans = 0;
		while (b != 0) {
			if ((b & 1) != 0) {
				// 考察b当前最右的状态！
				//如若被乘的数最右位有1， 就把它加
				ans = add(ans, a);
			}
			a <<= 1;
			b >>>= 1;//b要无符号右移动
		}
		return ans;
	}

}
